<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Glucose Response by Meal & Health Group</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    #controls {
      margin-bottom: 10px;
    }
    .checkbox-group label,
    .radio-group label {
      margin-right: 10px;
    }
    .tooltip {
      position: absolute;
      background: white;
      border: 1px solid #aaa;
      padding: 6px;
      pointer-events: none;
      opacity: 0;
      font-size: 12px;
    }
    .line {
      fill: none;
      stroke-width: 2px;
    }
    .area {
      opacity: 0.2;
    }
    .axis-label {
      font-size: 12px;
      fill: #333;
    }
  </style>
</head>
<body>
<h2>How do different meals affect blood sugar?</h2>
<p><em>Select one or more meal types and choose a health group to explore average Libre GL curves Â± one standard deviation.</em></p>
<div id="controls">
  <div class="checkbox-group" id="mealTypeCheckboxes"></div>
  <div class="radio-group" id="healthGroupRadios">
    <label><input type="radio" name="healthGroup" value="All" checked> All Groups</label>
    <label><input type="radio" name="healthGroup" value="Healthy"> Healthy</label>
    <label><input type="radio" name="healthGroup" value="Type 2 diabetic"> Type 2 Diabetic</label>
  </div>
</div>
<div id="chart"></div>
<div class="tooltip" id="tooltip"></div>
<script>
(async function () {
  const validMeals = ['Breakfast', 'Lunch', 'Dinner', 'Snack'];
  const validGroups = ['Healthy', 'Type 2 diabetic'];

  const data = await d3.csv('glucose_curves_summary.csv', d => {
    return {
      MealType: d.MealType.trim(),
      HealthGroup: d.HealthGroup.trim(),
      MinutesSinceMeal: +d.MinutesSinceMeal,
      libreMean: +d['Libre GL mean'],
      libreStd: +d['Libre GL std']
    };
  });

  const color = d3.scaleOrdinal()
    .domain(validGroups)
    .range(['steelblue', 'red']);

  let selectedMeals = new Set(validMeals);
  let selectedGroup = 'All';

  const checkboxContainer = d3.select('#mealTypeCheckboxes');
  validMeals.forEach(meal => {
    checkboxContainer.append('label')
      .html(`<input type="checkbox" value="${meal}" checked> ${meal}`);
  });

  d3.selectAll('#mealTypeCheckboxes input[type=checkbox]').on('change', function () {
    const meal = this.value;
    if (this.checked) {
      selectedMeals.add(meal);
    } else {
      selectedMeals.delete(meal);
    }
    update();
  });

  d3.selectAll('input[name="healthGroup"]').on('change', function () {
    selectedGroup = this.value;
    update();
  });

  const margin = { top: 20, right: 30, bottom: 40, left: 50 };
  const width = 800 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;

  const svg = d3.select('#chart').append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

  const x = d3.scaleLinear().range([0, width]).domain([0, 120]);
  const y = d3.scaleLinear().range([height, 0]);

  const xAxis = svg.append('g').attr('transform', `translate(0,${height})`);
  const yAxis = svg.append('g');

  svg.append('text')
    .attr('class', 'axis-label')
    .attr('x', width / 2).attr('y', height + 35)
    .attr('text-anchor', 'middle')
    .text('Minutes Since Meal');

  svg.append('text')
    .attr('class', 'axis-label')
    .attr('transform', 'rotate(-90)')
    .attr('x', -height / 2).attr('y', -40)
    .attr('text-anchor', 'middle')
    .text('Glucose (mg/dL)');

  const line = d3.line()
    .x(d => x(d.MinutesSinceMeal))
    .y(d => y(d.libreMean));

  const area = d3.area()
    .x(d => x(d.MinutesSinceMeal))
    .y0(d => y(d.libreMean - d.libreStd))
    .y1(d => y(d.libreMean + d.libreStd));

  function update() {
    let subset = data.filter(d => selectedMeals.has(d.MealType));
    let grouped;

    if (selectedGroup === 'All') {
      grouped = d3.group(subset, d => d.HealthGroup);
    } else {
      grouped = d3.group(subset.filter(d => d.HealthGroup === selectedGroup), d => d.HealthGroup);
    }

    const groupedArray = Array.from(grouped);

    const yMin = d3.min(subset, d => d.libreMean - d.libreStd);
    const yMax = d3.max(subset, d => d.libreMean + d.libreStd);
    y.domain([yMin, yMax]).nice();

    xAxis.transition().duration(750).call(d3.axisBottom(x).ticks(10));
    yAxis.transition().duration(750).call(d3.axisLeft(y));

    const groups = svg.selectAll('.group')
      .data(groupedArray, d => d[0]);

    groups.exit().remove();

    const groupsEnter = groups.enter().append('g').attr('class', 'group');
    groupsEnter.append('path').attr('class', 'area');
    groupsEnter.append('path').attr('class', 'line');

    groups.select('.area')
      .transition().duration(750)
      .attr('fill', d => color(d[0]))
      .attr('d', d => area(d[1]));

    groups.select('.line')
      .transition().duration(750)
      .attr('stroke', d => color(d[0]))
      .attr('d', d => line(d[1]));
  }

  update();
})();
</script>
</body>
</html>